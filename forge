#!/usr/bin/env python3

# Copyright (C) 2019-2022 Internet Systems Consortium, Inc. ("ISC")
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""Forge - testing tool for Kea and ISC DHCP."""

from __future__ import print_function
import boto3
import os
import sys
import time
import json
import shutil
import string
import logging
import tempfile
import datetime
import argparse
import textwrap
import functools
import subprocess
import configparser
from botocore.exceptions import ClientError
from urllib.parse import urljoin
from collections import defaultdict
try:
    import urllib.request
except:
    pass

log = logging.getLogger()

FORGE_INI = 'forge.ini'

SRV4_ADDR = "192.168.50.252"
CLNT4_ADDR = "192.168.50.2"
CLNT4_ADDR_2 = "192.168.51.2"
SRV_IPV6_ADDR_GLOBAL = "2001:db8:1::1000"
CLNT6_ADDR = "2001:db8:1::2000"
MGMT_ADDRESS = "172.28.0.31"
MGMT_ADDRESS_2 = "172.28.0.32"
MGMT_ADDRESS_3 = "172.28.0.33"
DNS4_ADDR = SRV4_ADDR
#DNS6_ADDR = "2001:db8:0:f101::1"
DNS6_ADDR = SRV_IPV6_ADDR_GLOBAL
IFACE = "enp0s9"
SERVER_IFACE = "enp0s9"
SERVER2_IFACE = "enp0s9"
INSTALL_METHOD = "make"
DNS_DATA_PATH = '/etc/bind/'

INIT_ALL = """
LOGLEVEL = "info"
IFACE = "{IFACE}"
SERVER_IFACE = "{SERVER_IFACE}"
SERVER2_IFACE = "{SERVER2_IFACE}"
DNS4_ADDR = "{DNS4_ADDR}"
DNS6_ADDR = "{DNS6_ADDR}"
WIN_DNS_ADDR_2016 = "{WIN_DNS_ADDR_2016}"
WIN_DNS_ADDR_2019 = "{WIN_DNS_ADDR_2019}"
SOFTWARE_UNDER_TEST = "kea4_server", "bind9_server",
SOFTWARE_INSTALL_PATH = "/usr/local"
DB_TYPE = "memfile"
SHOW_PACKETS_FROM = "both"
SRV4_ADDR = "{SRV4_ADDR}"
REL4_ADDR = "0.0.0.0"
GIADDR4 = "192.168.50.3"
CIADDR = "192.168.50.3"
CLI_LINK_LOCAL = ""
copylist = []
removelist = []
OUTPUT_WAIT_INTERVAL = 1
OUTPUT_WAIT_MAX_INTERVALS = 2
PACKET_WAIT_INTERVAL = 1
SRV_IPV6_ADDR_GLOBAL = "{SRV_IPV6_ADDR_GLOBAL}"
SRV_IPV6_ADDR_LINK_LOCAL = "fe80::a00:27ff:fedf:63bc"
CLNT6_ADDR = "{CLNT6_ADDR}"
HISTORY = True
TCPDUMP = False
TCPDUMP_PATH = ""
SAVE_CONFIG_FILE = True
AUTO_ARCHIVE = False
SLEEP_TIME_1 = 1  # wait after starting remote server
SLEEP_TIME_2 = 2  # wait after all others commands
MGMT_ADDRESS = "{MGMT_ADDRESS}"
MGMT_ADDRESS_2 = "{MGMT_ADDRESS_2}"
MGMT_ADDRESS_3 = "{MGMT_ADDRESS_3}"
MGMT_USERNAME = "vagrant"
MGMT_PASSWORD = "vagrant"
SAVE_LOGS = True
BIND_LOG_TYPE = "ERROR"
BIND_LOG_LVL = 0
BIND_MODULE = "*"
SAVE_LEASES = True
DNS_IFACE = "enp0s9"
DNS_PORT = 53
DNS_SERVER_INSTALL_PATH = "/usr/sbin/"
DNS_DATA_PATH = "{DNS_DATA_PATH}"
ISC_DHCP_LOG_FACILITY = "local7"
ISC_DHCP_LOG_FILE = "/var/log/forge_dhcpd.log"
DB_NAME = "keadb"
DB_USER = "keauser"
DB_PASSWD = "keapass"
DB_HOST = ""
FABRIC_PTY = ""
INSTALL_METHOD = "{INSTALL_METHOD}"
MULTI_THREADING_ENABLED = True
"""


CONFIG_FIELDS = ['kea-dirs', 'ccache-dir']


def _load_config():
    config = configparser.ConfigParser()
    if os.path.exists(FORGE_INI):
        config.read(FORGE_INI)
    if not config.has_section('Forge'):
        config.add_section('Forge')
    return config


def _save_config(config):
    with open(FORGE_INI, 'w') as configfile:
        config.write(configfile)


def update_config(name, value):
    if name not in CONFIG_FIELDS:
        raise Exception('Unknown config field %s' % name)
    if name == 'kea-dirs':
        value = os.path.abspath(value)
        if not os.path.exists(value):
            raise Exception('Folder %s does not exists.' % value)
        if not os.path.isdir(value):
            raise Exception('%s is not a directory.' % value)

    print('Setting %s to %s' % (name, value))
    cfg = _load_config()
    cfg.set('Forge', name, value)
    _save_config(cfg)


def show_config(name):
    cfg = _load_config()
    if name:
        if name not in CONFIG_FIELDS:
            raise Exception('Unknown config field %s' % name)
        print('%s = %s' % (name, cfg['Forge'][name]))
    else:
        for k, v in cfg['Forge'].items():
            print('%s = %s' % (k , v))


class ExecutionError(Exception):
    """Exception thrown when execution encountered an error."""
    pass


def execute(cmd, timeout=60, cwd=None, env=None, raise_error=True, dry_run=False, log_file_path=None,
            quiet=False, check_times=False, capture=False, interactive=False, attempts=1,
            sleep_time_after_attempt=None, log_prefix='{ts} '):
    """Execute a command in shell.

    :param str cmd: a command to be executed
    :param int timeout: timeout in number of seconds, after that time the command is terminated
                        but only if check_times is True
    :param str cwd: current working directory for the command
    :param dict env: dictionary with environment variables
    :param bool raise_error: if False then in case of error exception is not raised,
                             default: True ie exception is raise
    :param bool dry_run: if True then the command is not executed
    :param str log_file_path: if provided then all traces from the command are stored in indicated file
    :param bool quiet: if True then the command's traces are not printed to stdout
    :param bool check_times: if True then timeout is taken into account
    :param bool capture: if True then the command's traces are captured and returned by the function
    :param bool interactive: if True then stdin and stdout are not redirected, traces handling is disabled,
                             used for e.g. SSH
    :param int attemts: number of attempts to run the command if it fails
    :param int sleep_time_after_attempt: number of seconds to sleep before taking next attempt
    """
    log.info('>>>>> Executing %s in %s', cmd, cwd if cwd else os.getcwd())
    if not check_times:
        timeout = None
    if dry_run:
        return 0

    if 'sudo' in cmd and env:
        # if sudo is used and env is overridden then to preserve env add -E to sudo
        cmd = cmd.replace('sudo', 'sudo -E')

    if log_file_path:
        log_file = open(log_file_path, "wb")

    for attempt in range(attempts):
        if interactive:
            p = subprocess.Popen(cmd, cwd=cwd, env=env, shell=True)
            exitcode = p.wait()

        else:
            p = subprocess.Popen(cmd, cwd=cwd, env=env, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

            if capture:
                output = ''
            t0 = time.time()
            t1 = time.time()
            # repeat until process is running or timeout not occured
            while p.poll() is None and (timeout is None or t1 - t0 < timeout):
                line = p.stdout.readline()
                if line:
                    now = datetime.datetime.now()
                    lp = log_prefix.format_map(defaultdict(str, ts=now.strftime('%H:%M:%S.%f')))
                    line_decoded = lp + line.decode(errors='ignore').rstrip() + '\r'
                    line_decoded = line_decoded.replace(r'\n', '\n')
                    if not quiet:
                        print(line_decoded)
                    if capture:
                        output += line_decoded
                    if log_file_path:
                        log_file.write(line)
                t1 = time.time()

            # If no exitcode yet, ie. process is still running then it means that timeout occured.
            # In such case terminate the process and raise an exception.
            if p.poll() is None:
                # kill using sudo to be able to kill other sudo commands
                execute('sudo kill -s TERM %s' % p.pid)
                time.sleep(5)
                # if still running, kill harder
                if p.poll() is None:
                    execute('sudo kill -s KILL %s' % p.pid)
                msg = "Execution timeout, %d > %d seconds elapsed (start: %d, stop %d), cmd: '%s'"
                msg = msg % (t1 - t0, timeout, t0, t1, cmd)
                raise ExecutionError(msg)
            exitcode = p.returncode

        if exitcode == 0:
            break
        elif attempt < attempts - 1:
            txt = 'command failed, retry, attempt %d/%d' % (attempt, attempts)
            if log_file_path:
                txt_to_file = '\n\n[FORGE] %s\n\n\n' % txt
                log_file.write(txt_to_file.encode('ascii'))
            log.info(txt)
            if sleep_time_after_attempt:
                time.sleep(sleep_time_after_attempt)

    if log_file_path:
        log_file.close()

    if exitcode != 0 and raise_error:
        raise ExecutionError("The command return non-zero exitcode %s, cmd: '%s'" % (exitcode, cmd))

    if capture:
        return exitcode, output
    return exitcode


def _get_win_addresses(vars, version):
    """
    Update forge configuration with ip addresses of windows systems
    :param vars: string, include entire forge configuration
    :param version: string, contain release year of windows systems, in our setup it's 2016 or 2019
    :return: string, updated forge configuration
    """
    vars[f'WIN_DNS_ADDR_{version}'] = ''
    if os.path.exists(f'aws-win-ad-dns-vm{version}.txt'):
        with open(f'aws-win-ad-dns-vm{version}.txt', 'r') as f:
            for line in f.readlines():
                if line.startswith('ip-address='):
                    vars[f'WIN_DNS_ADDR_{version}'] = line[11:].strip()
                    log.info(f'extended forge configuration with WIN_DNS_ADDR_{version}=%s',
                             vars[f'WIN_DNS_ADDR_{version}'])
    else:
        log.info(f"aws-win-ad-dns-vm{version}.txt not found! Tests for GSS TSIG and ACTIVE DIRECTORY won't work")
    return vars


def set_init_all(args):
    # generate init_all.py
    my_vars = globals()

    if hasattr(args, 'native') and args.native:
        my_vars['INSTALL_METHOD'] = 'native'
    if args.system.startswith('fedora'):
        my_vars['DNS_DATA_PATH'] = '/etc/'

    my_vars = _get_win_addresses(my_vars, '2016')
    my_vars = _get_win_addresses(my_vars, '2019')

    txt = INIT_ALL.format(**my_vars)

    if args.dhcpd:
        tmp_txt = ""
        for line in txt.split('\n'):
            if not line.startswith('SOFTWARE_UNDER_TEST') or not line.startswith('PACKET_WAIT_INTERVAL'):
                tmp_txt += f'\n{line}'
        tmp_txt += '\nSOFTWARE_UNDER_TEST = "isc_dhcp4_server", "bind9_server",'
        tmp_txt += '\nDISABLE_DB_SETUP = True'
        tmp_txt += '\nPACKET_WAIT_INTERVAL = 3'
        txt = tmp_txt

    path = os.path.abspath('init_all.py')
    with open(path, 'w') as f:
        f.write(txt)
    print('Generated %s.' % path)


def get_vagrant_dir(args):
    vagrant_dir = os.path.join('vagrant',
                               'lxc' if args.lxc else 'vbox',
                               args.sid if args.sid else 'default',
                               args.system)
    vagrant_dir = os.path.abspath(vagrant_dir)
    return vagrant_dir


def _sanitize_sid(sid: str):
    """
    Remove underscores from setup ID to make it a valid name in various low-level operations.
    :param sid: setup ID
    :return: sanitized setup ID
    """
    return sid.replace('_', '') if sid else ''


def _get_interface_names(sid):
    """
    Get the names of interfaces used in LXC. Remove underscores from setup ID to make for a valid
    interface name.
    :param sid: setup ID
    :return: pair of (management interface name, traffic interface name)
    """
    sid = _sanitize_sid(sid)
    management_bridge = 'm' + sid
    traffic_bridge = 't' + sid
    return management_bridge, traffic_bridge


def ensure_lxc_bridges(args):
    mgmt_brg, traffic_brg = _get_interface_names(args.sid)
    for bridge in [mgmt_brg, traffic_brg]:
        if execute('sudo ip link show dev %s' % bridge, raise_error=False):
            execute('sudo ip link add dev %s type bridge' % bridge)
        execute('sudo ip link set dev %s up' % bridge)


def delete_lxc_bridges(args):
    mgmt_brg, traffic_brg = _get_interface_names(args.sid)
    for bridge in [mgmt_brg, traffic_brg]:
        if not execute('sudo ip link show dev %s' % bridge, raise_error=False):
            execute('sudo ip link set dev %s down' % bridge)
            execute('sudo ip link del dev %s' % bridge)


def _get_server_name(args, idx):
    if args.system == 'ubuntu-18.04':
        short_sys = 'u1804'
    elif args.system == 'ubuntu-20.04':
        short_sys = 'u2004'
    elif args.system == 'fedora-30':
        short_sys = 'f30'
    elif args.system == 'fedora-32':
        short_sys = 'f32'
    elif args.system == 'fedora-34':
        short_sys = 'f34'
    else:
        raise Exception('unsupported system %s' % args.system)

    name = 'forge-srv%d-%s' % (idx, short_sys)
    if args.sid:
        name += '-' + _sanitize_sid(args.sid)

    return name


def _destroy_lxc_containers(args):
    client_name = 'forge-client-' + _sanitize_sid(args.sid)
    server1_name = _get_server_name(args, 1)
    server2_name = _get_server_name(args, 2)

    for cntr in [client_name, server1_name, server2_name]:
        execute('sudo lxc-stop --name %s' % cntr, raise_error=False)
        execute('sudo lxc-destroy --name %s' % cntr, raise_error=False)


def _setup_win_ad_dns(ami, domain):
    """
    Strictly for AWS testing, this will start vm based on ami. Use _terminate_instances to
    terminate started systems, simple check is included to prevent starting multiple windows
    system
    @param ami: ami of vm template
    @param domain: windows domain
    @return: boto3 Instance
    """
    if os.path.exists(f'aws-win-ad-dns-vm{domain[3:7]}.txt'):
        log.info(f"file aws-win-ad-dns-vm{domain[3:7]}.txt exists it's possible that vm is already running!")
        log.info("please check if that's correct and use terminate-instances before setting up new systems!")
        sys.exit()
    import boto3
    log.info('creating windows vm for gss-tsig testing')
    ec2 = boto3.resource('ec2', region_name='us-east-1')
    init_script = """
<powershell>
shutdown /s /t 25200
</powershell>
<persist>true</persist>
    """
    params = dict(MaxCount=1,
                  MinCount=1,
                  InstanceType='t3a.small',
                  ImageId=ami,
                  SubnetId='subnet-0efca44a30c0a40c0',
                  KeyName='jenkins-ec2',
                  SecurityGroupIds=['sg-04a74236a5389e87f'],  # DomainController
                  TagSpecifications=[{'ResourceType': 'instance', 'Tags': [
                      {'Key': 'isc:purpose', 'Value': 'forge-testing'},
                      {'Key': 'isc:owner', 'Value': 'jenkins-ec2'},
                      {'Key': 'isc:group', 'Value': 'kea'},
                      {'Key': 'isc:provisioning', 'Value': 'python-api'},
                      {'Key': 'isc:access', 'Value': 'private'},
                      {'Key': 'isc:contact', 'Value': 'qa@isc.org'},
                      {'Key': 'Name', 'Value': f'j-windows-{domain[3:7]}-forge-testing'}
                  ]}],
                  InstanceInitiatedShutdownBehavior='terminate',
                  UserData=init_script)

    i = list(ec2.create_instances(**params))[0]
    with open(f'aws-win-ad-dns-vm{domain[3:7]}.txt', 'w') as f:
        f.write(f'instance-id={i.id}\n')
        f.write(f'domain={domain}\n')
    log.info(f'windows vm using domain {domain} and instance-id: {i.id}')
    return i


def _terminate_single_vm(instance):
    """
    terminate single vm in AWS
    @param instance: instance class to be terminated
    @return: True if termination was successful
    """
    log.info(f'>>>>> Terminating vm with id {instance.id} in progress..')
    try:
        instance.terminate()
        instance.wait_until_terminated()
    except ClientError as er:
        log.error(f'>>>>> There was a problem with termination of {instance.id}: {er}.')
        return False
    log.info(f'>>>>> AWS vm {instance.id} terminated.')
    return True


def _terminate_instances(args):
    """
    Strictly for AWS testing, this will terminate previously started vms by ./forge setup --win-gss-tsig
    """
    ec2 = boto3.resource('ec2', region_name='us-east-1')
    if args.id is not None:
        vms = args.id.split(",")
        for vm_id in vms:
            instance = ec2.Instance(vm_id)
            _terminate_single_vm(instance)
    else:
        for i in ("2016", "2019"):
            if os.path.exists(f'aws-win-ad-dns-vm{i}.txt'):
                with open(f'aws-win-ad-dns-vm{i}.txt', 'r') as f:
                    for line in f.readlines():
                        if line.startswith('instance-id='):
                            vm_id = line[12:].strip()
                            instance = ec2.Instance(vm_id)
                            if _terminate_single_vm(instance):
                                os.rename(f'aws-win-ad-dns-vm{i}.txt', f'aws-win-ad-dns-vm{i}_terminated.txt')
            else:
                log.info(f'aws-win-ad-dns-vm{i}.txt not found, looks like systems were not started!')


def setup(args):
    # load config
    cfg = _load_config()

    win_vm_2016 = None
    win_vm_2019 = None

    if args.win_gss_tsig:
        win_vm_2016 = _setup_win_ad_dns('ami-08065ac07e6a96549', 'win2016ad.aws.isc.org')
        win_vm_2019 = _setup_win_ad_dns('ami-06602a989923b1eba', 'win2019ad.aws.isc.org')

    set_init_all(args)

    if args.lxc:
        vagrant_tpl = 'vagrant/Vagrantfile.lxc.in'
    else:
        vagrant_tpl = 'vagrant/Vagrantfile.in'

    if 'ubuntu' in args.system or 'debian' in args.system:
        pkg = 'deb'
    else:
        pkg = 'rpm'

    server_image = 'kea-' + args.system

    client_name = 'forge-client-' + _sanitize_sid(args.sid)
    server1_name = _get_server_name(args, 1)
    server2_name = _get_server_name(args, 2)
    mgmt_brg, traffic_brg = _get_interface_names(args.sid)

    # generate global addresses for servers
    srv1_addr4 = SRV4_ADDR
    parts = SRV4_ADDR.rsplit('.', 1)
    srv2_addr4 = '%s.%d' % (parts[0], int(parts[1]) + 1)
    srv1_addr6 = SRV_IPV6_ADDR_GLOBAL
    parts = SRV_IPV6_ADDR_GLOBAL.rsplit(':', 1)
    srv2_addr6 = '%s:%04d' % (parts[0], int(parts[1]) + 1)

    # generate Vagrantfile
    with open(vagrant_tpl, 'r') as f_in:
        txt = f_in.read()
    tpl = string.Template(txt)
    txt = tpl.safe_substitute(KEA_DIRS=cfg['Forge']['kea-dirs'],
                              CCACHE_DIR=cfg['Forge']['ccache-dir'],
                              MGMT_ADDRESS=MGMT_ADDRESS,
                              MGMT_ADDRESS_2=MGMT_ADDRESS_2,
                              SRV4_ADDR_1=srv1_addr4,
                              SRV4_ADDR_2=srv2_addr4,
                              CLNT4_ADDR=CLNT4_ADDR,
                              CLNT4_ADDR_2=CLNT4_ADDR_2,
                              SRV_IPV6_ADDR_GLOBAL_1=srv1_addr6,
                              SRV_IPV6_ADDR_GLOBAL_2=srv2_addr6,
                              CLNT6_ADDR=CLNT6_ADDR,
                              IFACE=IFACE,
                              SERVER_IFACE=SERVER_IFACE,
                              SERVER2_IFACE=SERVER2_IFACE,
                              CLIENT_NAME=client_name,
                              SERVER1_NAME=server1_name,
                              SERVER2_NAME=server2_name,
                              MGMT_BRG=mgmt_brg,
                              TRAFFIC_BRG=traffic_brg,
                              SERVER_IMAGE=server_image,
                              PKG=pkg)
    vagrant_dir = get_vagrant_dir(args)
    if not os.path.exists(vagrant_dir):
        os.makedirs(vagrant_dir)
    vagrant_file = os.path.join(vagrant_dir, 'Vagrantfile')
    with open(vagrant_file, 'w') as f_out:
        f_out.write(txt)
    print('Generated %s.' % vagrant_file)

    # in case of LXC prepare bridges
    if args.lxc:
        ensure_lxc_bridges(args)

    if args.command == 'setup':
        # destroy VMs via Vagrant
        execute('vagrant destroy -f', cwd=vagrant_dir)

        if args.lxc:
            # in case of LXC to be sure destroys containers explicitly
            _destroy_lxc_containers(args)

        # create and start VMs via Vagrant
        try:
            execute('vagrant up', cwd=vagrant_dir)
        except ExecutionError:
            # let's retry all but not in parallel
            execute('vagrant destroy -f', cwd=vagrant_dir)
            if args.lxc:
                # in case of LXC to be sure destroys containers explicitly
                _destroy_lxc_containers(args)
            # we don't have solution if this fail
            execute('vagrant up --no-parallel', cwd=vagrant_dir)

    elif args.command == 'refresh':
        # reload and reprovision VMs via Vagrant if requested
        reload_ = args.reload
        provision = args.provision
        if not reload_ and not provision:
            reload_ = True
            provision = True
        if reload_:
            execute('vagrant reload', cwd=vagrant_dir)
        if provision:
            execute('vagrant provision', cwd=vagrant_dir)

    if args.win_gss_tsig:
        win_vm_2016.wait_until_running()
        win_vm_2016.reload()
        win_dns_addr = win_vm_2016.private_ip_address
        with open('aws-win-ad-dns-vm2016.txt', 'a') as f:
            f.write('ip-address=%s\n' % win_dns_addr)
        log.info('windows 2016 vm ip-address: %s' % win_dns_addr)

        win_vm_2019.wait_until_running()
        win_vm_2019.reload()
        win_dns_addr = win_vm_2019.private_ip_address
        with open('aws-win-ad-dns-vm2019.txt', 'a') as f:
            f.write('ip-address=%s\n' % win_dns_addr)
        log.info('windows 2019 vm ip-address: %s' % win_dns_addr)

        # we want again recreate init all to save windows dns ip addresses
        set_init_all(args)


def install_kea(args):
    ensure_lxc_bridges(args)

    vagrant_dir = get_vagrant_dir(args)
    execute('vagrant up', cwd=vagrant_dir, raise_error=False)

    if args.version:
        _install_kea_native(args)
    else:
        _install_kea_make(args)


def _install_kea_native(args):
    _install_kea_native_on_server(args, 1)
    _install_kea_native_on_server(args, 2)


def _upload_content(content, server_name, path, vagrant_dir, log_prefix):
    fp = tempfile.NamedTemporaryFile(mode='w', delete=False)
    fp.write(content)
    fp.close()
    tp = '/tmp/aaa-%s' % time.time()
    cmd = 'vagrant upload %s %s %s' % (fp.name, tp, server_name)
    execute(cmd, cwd=vagrant_dir, attempts=3, log_prefix=log_prefix)
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'
    cmd = cmd_tpl % ('sudo cp %s %s' % (tp, path))
    execute(cmd, cwd=vagrant_dir, attempts=3, log_prefix=log_prefix)
    os.unlink(fp.name)


def _install_krb_on_ubuntu(server_name, vagrant_dir, log_prefix):
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'

    subcmd = 'sudo DEBIAN_FRONTEND=noninteractive apt install -y krb5-kdc krb5-admin-server libkrb5-dev dnsutils'
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

    # /etc/krb5.conf
    krb5_conf = """[libdefaults]
        default_realm = EXAMPLE.COM
        kdc_timesync = 1
        ccache_type = 4
        forwardable = true
        proxiable = true
[realms]
        EXAMPLE.COM = {
                kdc = 192.168.50.252
                admin_server = 192.168.50.252
        }
"""
    _upload_content(krb5_conf, server_name, '/etc/krb5.conf', vagrant_dir, log_prefix)

    # /etc/krb5kdc/kdc.conf
    kdc_conf = """[kdcdefaults]
    kdc_ports = 750,88

[realms]
    EXAMPLE.COM = {
        database_name = /var/lib/krb5kdc/principal
        default_ccache_name = FILE:/tmp/krb5cc_%{{uid}}
        admin_keytab = FILE:/etc/krb5kdc/kadm5.keytab
        acl_file = /etc/krb5kdc/kadm5.acl
        key_stash_file = /etc/krb5kdc/stash
        kdc_ports = 750,88
        max_life = 0h 3m 0s
        max_renewable_life = 0d 0h 3m 0s
        master_key_type = des3-hmac-sha1
        #supported_enctypes = aes256-cts:normal aes128-cts:normal
        default_principal_flags = +preauth
    }
        """
    _upload_content(kdc_conf, server_name, '/etc/krb5kdc/kdc.conf', vagrant_dir, log_prefix)

    subcmd = "sudo test -e /var/lib/krb5kdc/principal || printf '123\\n123' | sudo krb5_newrealm"
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)


def _install_krb_on_fedora(server_name, vagrant_dir, log_prefix):
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'

    subcmd = 'sudo dnf install -y krb5-server krb5-workstation'
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

    # /etc/krb5.conf
    krb5_conf = """includedir /etc/krb5.conf.d/

[logging]
    default = FILE:/var/log/krb5libs.log
    kdc = FILE:/var/log/krb5kdc.log
    admin_server = FILE:/var/log/kadmind.log

[libdefaults]
    dns_lookup_realm = false
    ticket_lifetime = 24h
    renew_lifetime = 7d
    forwardable = true
    rdns = false
    pkinit_anchors = FILE:/etc/pki/tls/certs/ca-bundle.crt
    spake_preauth_groups = edwards25519
    dns_canonicalize_hostname = fallback
    qualify_shortname = ""
    default_realm = EXAMPLE.COM
    default_ccache_name = KEYRING:persistent:%{uid}

[realms]
    EXAMPLE.COM = {
        kdc = 192.168.50.252
        admin_server = 192.168.50.252
    }
"""
    _upload_content(krb5_conf, server_name, '/etc/krb5.conf', vagrant_dir, log_prefix)

    subcmd = "sudo test -e /var/kerberos/krb5kdc/principal || printf '123\\n123' | sudo kdb5_util create -s"
    cmd = cmd_tpl % subcmd
    execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)


def _install_kea_native_on_server(args, server_idx):
    vagrant_dir = get_vagrant_dir(args)
    server_name = _get_server_name(args, server_idx)
    log_prefix = "|%s {ts}| " % server_name
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'

    # copy hammer into vm and prepare system
    execute('rm -rf hammer.py', cwd=vagrant_dir)
    execute('wget https://gitlab.isc.org/isc-projects/kea/raw/master/hammer.py', cwd=vagrant_dir)
    execute('chmod a+x hammer.py', cwd=vagrant_dir)
    cmd = 'vagrant upload hammer.py %s' % server_name
    execute(cmd, cwd=vagrant_dir, attempts=3, log_prefix=log_prefix)

    cmd = cmd_tpl % './hammer.py prepare-system -p local -x unittest docs perfdhcp -w mysql,pgsql,radius,forge,shell'
    execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

    if server_idx == 1:
        if 'ubuntu' in args.system:
            _install_krb_on_ubuntu(server_name, vagrant_dir, log_prefix)
        else:
            _install_krb_on_fedora(server_name, vagrant_dir, log_prefix)

    # prepare pkg source repo url
    repository_url = 'https://packages.aws.isc.org'
    major_minor= '.'.join(args.version.split('.')[0:2])
    repo_name = f'kea-{major_minor}-{args.system}'
    repo_url = urljoin(repository_url, 'repository')
    repo_url += '/%s-ci/' % repo_name

    if 'ubuntu' in args.system:
        # fix certificate issue
        cmd = cmd_tpl % "sudo apt-get install -y ca-certificates openssl"
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)
        cmd = cmd_tpl % "sudo update-ca-certificates --fresh"
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)
        # setup pkg source repo in vm
        subcmd = "echo 'deb %s kea main' | sudo tee /etc/apt/sources.list.d/isc.list" % repo_url
        cmd = cmd_tpl % subcmd
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)
        key_url = "%s/repository/repo-keys/repo-key.gpg" % repository_url
        subcmd = 'wget -qO- %s | sudo apt-key add -' % key_url
        cmd = cmd_tpl % subcmd
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

        cmd = cmd_tpl % 'sudo apt update'
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

        # prepare packages list with versions
        # rather than remember to add new pkg to the list here, just install all
        pkgs = f"isc-kea-*={args.version} python3-isc-kea-connector={args.version}"

        # install packages
        cmd = cmd_tpl % 'sudo apt install -y -o Dpkg::Options::="--force-confnew" %s' % pkgs
        env = os.environ.copy()
        env['DEBIAN_FRONTEND'] = 'noninteractive'
        execute(cmd, cwd=vagrant_dir, env=env, log_prefix=log_prefix)

    elif 'fedora' in args.system:
        # setup pkg source repo in vm
        subcmd = 'cat <<EOF | sudo tee /etc/yum.repos.d/isc.repo\n'
        subcmd += '[nexus]\n'
        subcmd += 'name=ISC Repo\n'
        subcmd += 'baseurl=%s\n' % repo_url
        subcmd += 'enabled=1\n'
        subcmd += 'gpgcheck=0\n'
        subcmd += 'EOF\n'
        cmd = cmd_tpl % subcmd
        execute(cmd, cwd=vagrant_dir, log_prefix=log_prefix)

        # prepare packages list with versions
        # rather than remember to add new pkg to the list here, just install all
        pkgs = ["isc-kea*"]

        if args.system == 'fedora-30':
            suffix = 'fc30'
        elif args.system == 'fedora-32':
            suffix = 'fc32'
        elif args.system == 'fedora-34':
            suffix = 'fc34'
        else:
            raise NotImplementedError("System %s not supported" % args.system)

        sfx = '-%s.%s' % (args.version, suffix)
        pkgs = [p + sfx for p in pkgs]
        pkgs = " ".join(pkgs)

        # install packages
        cmd = cmd_tpl % 'sudo dnf install -y %s' % pkgs
        env = os.environ.copy()
        execute(cmd, cwd=vagrant_dir, env=env, log_prefix=log_prefix)


def _install_kea_make(args):
    _install_kea_make_on_server(args, 1)
    _install_kea_make_on_server(args, 2)


def _install_kea_make_on_server(args, server_idx):
    server_name = _get_server_name(args, server_idx)
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'
    log_prefix = "|%s {ts}| " % server_name

    cfg = _load_config()
    kea_dirs = cfg['Forge']['kea-dirs']
    local_kea_path = os.path.join(kea_dirs, args.path)
    if args.path == '':
        print('Path to Kea folder is empty. Give one of these:')
        for d in sorted(os.listdir(kea_dirs)):
            p = os.path.join(kea_dirs, d)
            if os.path.isdir(p):
                print('  %s' % d)
        exit(1)
    if not os.path.exists(local_kea_path):
        raise Exception('Folder %s does not exists.' % local_kea_path)
    if not os.path.isdir(local_kea_path):
        raise Exception('Folder %s is not a directory.' % local_kea_path)

    remote_path = os.path.join('/kea-dirs', args.path)
    subcmd_tpl = 'cd %s && ./hammer.py %s -p local -x unittest docs perfdhcp -w mysql,pgsql,radius,gssapi,forge,shell,ccache --ccache-dir /ccache'

    vagrant_dir = get_vagrant_dir(args)

    # install any missing dependencies and prepare system
    subcmd1 = subcmd_tpl % (remote_path, 'prepare-system')
    cmd1 = cmd_tpl % subcmd1
    execute(cmd1, cwd=vagrant_dir, log_prefix=log_prefix)

    if server_idx == 1:
        if 'ubuntu' in args.system:
            _install_krb_on_ubuntu(server_name, vagrant_dir, log_prefix)
        else:
            _install_krb_on_fedora(server_name, vagrant_dir, log_prefix)

    # do kea build
    subcmd2 = subcmd_tpl % (remote_path, 'build')
    cmd2 = cmd_tpl % subcmd2
    execute(cmd2, cwd=vagrant_dir, log_prefix=log_prefix)

    # make clean to reclaim disk space
    remote_kea_bld_dir = os.path.join(remote_path, 'kea-src/kea-0.0.1')
    subcmd3 = 'cd %s && make clean' % remote_kea_bld_dir
    cmd3 = cmd_tpl % subcmd3
    execute(cmd3, cwd=vagrant_dir, log_prefix=log_prefix)


def install_dhcpd(args):
    """
    Run ISC-DHCP installation on both systems
    :param args: parser arguments
    :return:
    """
    ensure_lxc_bridges(args)

    vagrant_dir = get_vagrant_dir(args)
    execute('vagrant up', cwd=vagrant_dir, raise_error=False)

    _install_dhcpd_on_server(args, 1)
    _install_dhcpd_on_server(args, 2)


def _install_dhcpd_on_server(args, server_idx):
    """
    Build and install ISC-DHCP on ubuntu system and enable logging
    :param args: forge arguments
    :param server_idx: id of a vm on which installation will be performed
    """
    server_name = _get_server_name(args, server_idx)
    cmd_tpl = 'vagrant ssh ' + server_name + ' -c "%s"'
    log_prefix = f"|{server_name} {{ts}}| "

    cfg = _load_config()
    kea_dirs = cfg['Forge']['kea-dirs']
    local_kea_path = os.path.join(kea_dirs, args.path)
    if args.path == '':
        print('Path to ISC-DHCP folder is empty. Give one of these:')
        for d in sorted(os.listdir(kea_dirs)):
            p = os.path.join(kea_dirs, d)
            if os.path.isdir(p):
                print('  %s' % d)
        exit(1)
    if not os.path.exists(local_kea_path):
        raise Exception('Folder %s does not exists.' % local_kea_path)
    if not os.path.isdir(local_kea_path):
        raise Exception('Folder %s is not a directory.' % local_kea_path)

    remote_path = os.path.join('/kea-dirs', args.path)

    vagrant_dir = get_vagrant_dir(args)

    # isc-dhcp is simple we don't need much, just compile and install
    cmd = f'cd {remote_path} && ./configure && make -j1 && sudo make install'
    execute(cmd_tpl % cmd, cwd=vagrant_dir, log_prefix=log_prefix)

    # enable logging for isc-dhcp
    cmd = "sudo sed -i '1s/^/local7.debug\\t\/var\/log\/forge_dhcpd.log\\n/' /etc/rsyslog.conf"
    execute(cmd_tpl % cmd, cwd=vagrant_dir, log_prefix=log_prefix)

    # restart syslog
    cmd = "sudo systemctl restart rsyslog"
    execute(cmd_tpl % cmd, cwd=vagrant_dir, log_prefix=log_prefix)


def test(args, params):
    set_init_all(args)

    ensure_lxc_bridges(args)

    vagrant_dir = get_vagrant_dir(args)
    if not args.version:
        execute('vagrant up', cwd=vagrant_dir, raise_error=False)

    params = ' '.join(params)
    print('Test params: %s' % params)
    client_name = 'forge-client-' + _sanitize_sid(args.sid)
    cmd = 'vagrant ssh ' + client_name + ' -c "%s"'
    subcmd = 'cd /forge/; sudo ~/venv/bin/pytest ' + params
    cmd %= subcmd
    try:
        execute(cmd, cwd=vagrant_dir, log_prefix='|%s {ts}| ' % client_name)  # , raise_error=False)
    except:
        # wait for all traces in executed command
        sys.stdout.flush()
        sys.stderr.flush()
        time.sleep(1)
        log.exception('ignored error in testing')


def clean(args):
    vagrant_dir = get_vagrant_dir(args)

    # destroy VMs
    execute('vagrant destroy -f', cwd=vagrant_dir, raise_error=False)

    if args.lxc:
        # in case of LXC to be sure destroys containers explicitly
        _destroy_lxc_containers(args)

    # clean files
    files_to_del = ['init_all.py',
                    os.path.join(vagrant_dir, 'Vagrantfile'),
                    os.path.join(vagrant_dir, 'hammer.py')]
    for path in files_to_del:
        path = os.path.abspath(path)
        if os.path.exists(path):
            os.unlink(path)
            print('Deleted %s.' % path)
    shutil.rmtree(os.path.join(vagrant_dir, '.vagrant'))

    # delete bridges
    if args.lxc:
        delete_lxc_bridges(args)

def _get_latest_cloud_version(image_tpl):
    url = 'https://app.vagrantup.com/api/v1/box/' + image_tpl
    try:
        with urllib.request.urlopen(url) as response:
            data = response.read()
    except:
        log.exception('ignored exception')
        return 0
    cloud_meta = json.loads(data)

    if 'versions' not in cloud_meta:
        return 0
    latest_version = 0
    for ver in cloud_meta['versions']:
        provider_found = False
        for p in ver['providers']:
            if p['name'] == 'lxc':
                provider_found = True
                break
        if provider_found:
            try:
                v = int(ver['number'])
            except:
                return ver['number']
            if v > latest_version:
                latest_version = v
    return latest_version


def _package_box(lxc_name, vagrant_dir, box_name):
    lxc_box_dir = os.path.join(vagrant_dir, 'lxc-box')
    if os.path.exists(lxc_box_dir):
        execute('sudo rm -rf %s' % lxc_box_dir)
    os.mkdir(lxc_box_dir)
    lxc_container_path = os.path.join('/var/lib/lxc', lxc_name)
    execute('sudo bash -c \'echo "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8ia'
            'llvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ'
            '6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTB'
            'ckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6k'
            'ivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmB'
            'YSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYC'
            'zRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key"'
            '> %s/rootfs/home/vagrant/.ssh/authorized_keys\'' % lxc_container_path)
    cmd = 'sudo bash -c "'
    cmd += 'cd %s '
    cmd += '&& tar --numeric-owner --anchored --exclude=./rootfs/dev/log -czf %s/rootfs.tar.gz ./rootfs/*'
    cmd += '"'
    execute(cmd % (lxc_container_path, lxc_box_dir))
    execute('sudo cp %s/config %s/lxc-config' % (lxc_container_path, lxc_box_dir))
    execute('sudo chown `id -un`:`id -gn` *', cwd=lxc_box_dir)
    with open(os.path.join(lxc_box_dir, 'metadata.json'), 'w') as f:
        now = datetime.datetime.now()
        f.write('{\n')
        f.write('  "provider": "lxc",\n')
        f.write('  "version":  "1.0.0",\n')
        f.write('  "built-on": "%s"\n' % now.strftime('%c'))
        f.write('}\n')

    box_path = os.path.join(vagrant_dir, box_name + '.box')
    execute('tar -czf %s ./*' % box_path, cwd=lxc_box_dir)
    execute('sudo rm -rf %s' % lxc_box_dir)
    return box_path


def package_box_and_upload(args):
    lxc_name = 'forge-client-' + _sanitize_sid(args.sid)
    box_name = 'forge-clt-%s' % args.system

    vagrant_dir = get_vagrant_dir(args)

    box_path = _package_box(lxc_name, vagrant_dir, box_name)

    image_tpl = 'isc/' + box_name
    latest_version = _get_latest_cloud_version(image_tpl)
    new_version = latest_version + 1
    cmd = "vagrant cloud publish -f -r %s %s %s %s"
    cmd = cmd % (image_tpl, new_version, 'lxc', box_path)
    execute(cmd)


def parse_args():
    """Parse arguments."""
    # used lambda to change args order and able to substitute width
    fl = functools.partial(lambda w, t: textwrap.fill(t, w), 80)
    description = [
        "Forge - testing tool for Kea and ISC DHCP.\n",
        "Basic steps for running Forge are as follows:\n"
        "1) first configure forge itself\n\n"
        "   ./forge config kea-dirs /path/to/kea/repos\n\n"
        "2) create VMs\n\n"
        "   ./forge setup\n\n"
        "3a) install Kea in one of VMs\n\n"
        "   ./forge install-kea kea-subdir\n\n"
        "3b) or instead of Kea install ISC-DHCP in one of VMs\n\n"
        "   ./forge install-dhcpd dhcpd-subdir\n\n"
        "4) run indicated tests, parameters are directly passed to pytest\n\n"
        "   ./forge test -m v4\n"
    ]
    description = "\n".join(description)
    main_parser = argparse.ArgumentParser(description=description,
                                          formatter_class=argparse.RawDescriptionHelpFormatter)

    main_parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode.')
    main_parser.add_argument('-q', '--quiet', action='store_true', help='Enable quiet mode.')
    main_parser.add_argument('--lxc', action='store_true', default=False,
                             help='Use LXC instead of VirtualBox.')
    main_parser.add_argument('--sid', default=None,
                             help='ID of setup. If more setups needed in parallel then run with specific ID.')
    main_parser.add_argument('-s', '--system', default='ubuntu-18.04',
                             help="Server system name, default: 'ubuntu-18.04'")

    subparsers = main_parser.add_subparsers(
        dest='command',
        title="Forge commands",
        description=fl("The following commands are provided by Forge. "
                       "To get more information about particular command invoke: "
                       "./forge <command> -h.\n"))

    parser = subparsers.add_parser('config', help="Set config parameter in config file ie. forge.ini.")
    parser.add_argument('name', nargs='?', default=None, help='Name of parameter.')
    parser.add_argument('value', nargs='?', default=None, help='Value for indicated parameter.')

    parser = subparsers.add_parser('setup', help="Create VMs where testing happens.")
    parser.add_argument('--win-gss-tsig', action='store_true',
                        help='Enable setup of Windows machine with AD/DNS for testing GSS-TSIG.')
    parser.add_argument('--dhcpd', action='store_true', help='Change settings to run tests for isc-dhcp.')

    parser = subparsers.add_parser('refresh', help="Refresh VMs ie. restart and re-provision")
    parser.add_argument('--reload', action='store_true', help='Reload only.')
    parser.add_argument('--provision', action='store_true', help='Re-provision only.')
    parser.add_argument('--dhcpd', action='store_true', help='Change settings to run tests for isc-dhcp.')

    parser = subparsers.add_parser('install-kea', help="Install Kea into VM from indicated repository.")
    parser.add_argument('path', default='', nargs='?', help='Sub-path to the repository.')
    parser.add_argument('--version', help='Version of packages.')

    parser = subparsers.add_parser('install-dhcpd', help="Install isc-dhcp into VM from indicated directory.")
    parser.add_argument('path', default='', nargs='?', help='Sub-path to the repository.')

    parser = subparsers.add_parser('test', help="Run tests. Parameters are passed directly to pytest.")
    parser.add_argument('--native', action='store_true', default=False, help='Use native packages for testing')
    parser.add_argument('--version', help='Install given version of packages.')
    parser.add_argument('--dhcpd', action='store_true', help='Change settings to run tests for isc-dhcp.')

    parser = subparsers.add_parser('terminate-instances',
                                   help="Terminate Windows machines with AD/DNS previously started for GSS-TSIG")
    parser.add_argument('--id', default=None,
                        help='Terminate AWS system with id, multiple ids can be passed separated by comma.')

    parser = subparsers.add_parser('clean', help="Destroy VMs")
    parser = subparsers.add_parser('box', help="Package LXC box and upload to cloud")

    args, rest = main_parser.parse_known_args()
    return args, rest, main_parser


def main():
    """Main function - parse args and invoke proper command."""
    args, rest, parser = parse_args()

    # prepare logging
    level = logging.INFO
    if args.verbose:
        level = logging.DEBUG
    fmt = '[FORGE]  %(asctime)-15s  %(message)s'
    logging.basicConfig(format=fmt, level=level)

    log.info('args %s', args)

    # dispatch command
    if args.command == 'config':
        if args.value is not None:
            update_config(args.name, args.value)
        else:
            show_config(args.name)

    elif args.command == 'setup':
        setup(args)

    elif args.command == "refresh":
        setup(args)

    elif args.command == "install-kea":
        install_kea(args)

    elif args.command == "install-dhcpd":
        install_dhcpd(args)

    elif args.command == "test":
        if args.version:
            install_kea(args)
        test(args, rest)

    elif args.command == "clean":
        clean(args)

    elif args.command == "box":
        package_box_and_upload(args)

    elif args.command == "terminate-instances":
        _terminate_instances(args)

    else:
        parser.print_help()


if __name__ == '__main__':
    main()
